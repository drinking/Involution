 区别主要在于加锁对CPU资源的消耗和线程的阻塞逐级递增. 是锁等待的一种策略.
 [https://www.cnblogs.com/paddix/p/5405678.html](https://www.cnblogs.com/paddix/p/5405678.html)
 
 
 ### [偏向锁状态](https://zhuanlan.zhihu.com/p/26475023)
 
 HotSpot支持存储释放偏向锁，以及偏向锁的批量重偏向和撤销。这个特性可以通过JVM的参数进行切换，而且这是默认支持的。Unlock状态下MarkWord的一个比特位用于标识该对象偏向锁是否被使用或者是否被禁止。如果该bit位为0，则该对象未被锁定，并且禁止偏向；如果该bit位为1，则意味着该对象处于以下三种状态：  

-   **匿名偏向(Anonymously biased)**  
    在此状态下thread_ptr为NULL(0)，意味着还没有线程偏向于这个锁对象。第一个试图获取该锁的线程将会面临这个情况，使用原子CAS指令可将该锁对象绑定于当前线程。这是允许偏向锁的类对象的初始状态。
-   **可重偏向(Rebiasable)**  
    在此状态下，偏向锁的epoch字段是无效的(与锁对象对应的klass的mark_prototype的epoch值不匹配)。下一个试图获取锁对象的线程将会面临这个情况，使用原子CAS指令可将该锁对象绑定于当前线程。在批量重偏向的操作中，未被持有的锁对象都被至于这个状态，以便允许被快速重偏向。
-   **已偏向(Biased)**  
    这种状态下，thread ptr非空，且epoch为有效值——意味着其他线程正在只有这个锁对象。
	
 
 
 ### 参考资料
 - [偏向锁与hashcode能共存吗？](https://blog.csdn.net/Saintyyu/article/details/108295657)
 - [死磕Synchronized底层实现--偏向锁](https://github.com/farmerjohngit/myblog/issues/13)
 - [Java Object.hashCode()返回的是对象内存地址？](https://juejin.cn/post/6844903487432556551)
 - [TODO java中的hashCode是怎么来的？](https://zhuanlan.zhihu.com/p/33915892)